"flqrgnkx-0" => "d4f76bdcbf838f8416ccfa8bc6d1f9e6"
"flqrgnkx-1" => "55eab3c4fbfede16dcec2c66dda26464"
"flqrgnkx-2" => "0adf13fa40e8ea815376776af3b7b231"

Self-contained does not mean that you need no external knowledge of algorithms. 
To solve day 14 you need to know two things: knothhash (presented in day 10 and 
linked in the puzzle description) and a 4-way flood fill (a well known algorithm, 
iff you had to use it before). I see no problem here.

public class Day14
{
    public int Part1(string input)
    {
        return string.Join(string.Empty, BuildMap(input)).Count(c => c == '1');
    }

    public int Part2(string input)
    {
        string[] hashes = BuildMap(input);

        bool[,] visited = new bool[128, 128];
        int regions = 0;

        for (int y = 0; y < visited.GetLength(1); y++) // rows
        {
            for (int x = 0; x < visited.GetLength(0); x++) // columns
            {
                if (visited[x, y] || hashes[x][y] == '0')
                {
                    continue;
                }

                this.Visit(x, y, hashes, visited);
                regions++;
            }
        }

        return regions;
    }

    private static string[] BuildMap(string input)
    {
        var hexMap = new Dictionary<char, string>
        {
            { '0', "0000" }, { '1', "0001" }, { '2', "0010" }, { '3', "0011" },
            { '4', "0100" }, { '5', "0101" }, { '6', "0110" }, { '7', "0111" },
            { '8', "1000" }, { '9', "1001" }, { 'a', "1010" }, { 'b', "1011" },
            { 'c', "1100" }, { 'd', "1101" }, { 'e', "1110" }, { 'f', "1111" }
        };

        var hasher = new Day10();
        var hashes = Enumerable.Range(0, 128)
                               .Select(i => $"{input}-{i}")
                               .Select(hasher.Part2)
                               .Select(hash => string.Join(string.Empty, hash.Select(c => hexMap[c])))
                               .ToArray();
        return hashes;
    }

    private void Visit(int x, int y, string[] input, bool[,] visited)
    {
        if (visited[x, y])
        {
            return;
        }

        visited[x, y] = true;

        if (input[x][y] == '0')
        {
            return;
        }

        if (x > 0)   this.Visit(x - 1, y, input, visited);
        if (x < 127) this.Visit(x + 1, y, input, visited);
        if (y > 0)   this.Visit(x, y - 1, input, visited);
        if (y < 127) this.Visit(x, y + 1, input, visited);
    }
}


int[,] grid = new int[128, 128];
List<ValueTuple<int, int>> coords = new List<ValueTuple<int, int>>();
int total = 0, used = 0; int bits = 0;
while (bits < 128)
{
    var bitstr = hex2bits(returnHash()); //day10 shit
    used = used + bitstr.Count(x => x == '1');
    populateGrid(bits, bitstr);
    bits++;
}
for (int i = 0; i < 128; i++)
{
    for (int j = 0; j < 128; j++)
    {
        if (grid[j, i] == 1 && !coords.Contains((j, i))) { getRegion(j, i); }
    }
}
Console.WriteLine($"Used: {used}, groups: {total}"); // the end
Console.ReadKey();
//helpers
void populateGrid(int row, string line) { for (int x = 0; x < 128; x++) { grid[x, row] = line[x] - '0'; } }
void getRegion(int x, int y)
{
    HashSet<ValueTuple<int, int>> temp = new HashSet<ValueTuple<int, int>>();
    temp.Clear(); temp.Add((x, y)); int c = 0;
    while (c < temp.Count)
    {
        x = temp.ElementAt(c).Item1; y = temp.ElementAt(c).Item2;
        if (x - 1 > -1 && grid[x - 1, y] == 1 && !coords.Contains((x-1, y))) { temp.Add((x-1, y)); }
        if (x + 1 < 128 && grid[x + 1, y] == 1 && !coords.Contains((x+1, y))) { temp.Add((x+1, y)); }
        if (y - 1 > -1 && grid[x, y - 1] == 1 && !coords.Contains((x, y-1))) { temp.Add((x, y-1)); }
        if (y + 1 < 128 && grid[x, y + 1] == 1 && !coords.Contains((x, y+1))) { temp.Add((x, y+1)); }
        c++;
    }
    coords.AddRange(temp); total++;
}

